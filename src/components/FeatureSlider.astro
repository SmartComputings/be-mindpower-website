---
import FeatureCard from './FeatureCard.astro';

interface Props {
  /** Tarjeta activa al cargar: 0=Chat, 1=Wallet, 2=Marketplace… Default 2 */
  initialIndex?: number;
}

const { initialIndex = 2 } = Astro.props;

// Slider: 9 tarjetas (Chat, Wallet, Marketplace, Apps, Nutrition, Comunidades, Música, Salud Mental, AI Finanzas)
const features = [
  {
    // Chat (0, activo por defecto)
    image: '/images/Chat.svg',
    logo: '/images/logohorizontal.svg',
    title: 'Chat',
    description: 'Comunicación segura, instantánea e inteligente.',
    titleKey: 'features.chat.title',
    descriptionKey: 'features.chat.description'
  },
  {
    image: '/images/wallet.svg',
    logo: '/images/logohorizontal.svg',
    title: 'Wallet',
    description: 'Tu billetera digital segura y conectada.',
    titleKey: 'features.wallet.title',
    descriptionKey: 'features.wallet.description'
  },
  {
    image: '/images/marketplace.svg',
    logo: '/images/logohorizontal.svg',
    title: 'Marketplace',
    description: 'Compra y vende de forma segura.',
    titleKey: 'features.marketplace.title',
    descriptionKey: 'features.marketplace.description'
  },
  {
    image: '/images/apps.svg',
    logo: '/images/logohorizontal.svg',
    title: 'Apps',
    description: 'Una sola puerta a cientos de soluciones.',
    titleKey: 'features.apps.title',
    descriptionKey: 'features.apps.description'
  },
  {
    image: '/images/nutrition.svg',
    logo: '/images/logohorizontal.svg',
    title: 'Nutrition',
    description: 'Alimentación inteligente para tu bienestar.',
    titleKey: 'features.nutrition.title',
    descriptionKey: 'features.nutrition.description'
  },
  {
    image: '/images/Community.svg',
    logo: '/images/logohorizontal.svg',
    title: 'Comunidades',
    description: 'Conecta con personas afines a ti.',
    titleKey: 'features.communities.title',
    descriptionKey: 'features.communities.description'
  },
  {
    image: '/images/musica.svg',
    logo: '/images/logohorizontal.svg',
    title: 'Música',
    description: 'Tu soundtrack personalizado.',
    titleKey: 'features.music.title',
    descriptionKey: 'features.music.description'
  },
  {
    image: '/images/mental.svg',
    logo: '/images/logohorizontal.svg',
    title: 'Salud Mental',
    description: 'Bienestar emocional con apoyo inteligente.',
    titleKey: 'features.mentalHealth.title',
    descriptionKey: 'features.mentalHealth.description'
  },
  {
    image: '/images/AiFinanzas.svg',
    logo: '/images/logohorizontal.svg',
    title: 'A.I. Finanzas',
    description: 'Gestión financiera inteligente y personalizada.',
    titleKey: 'features.finance.title',
    descriptionKey: 'features.finance.description'
  }
];

---

<section class="feature-slider relative w-full flex flex-col items-center justify-center overflow-visible" data-feature-slider>
  <div class="slider-wrapper relative w-full flex flex-col items-center justify-center flex-1 min-h-0">
    <div class="slider-container relative w-full flex-1 overflow-visible min-h-[320px]">
      <div 
        class="slider-track flex items-center justify-center"
        data-initial-index={initialIndex}
      >
        {features.map((feature, index) => (
          <div 
            class="slider-item absolute" 
            data-index={index}
            style={`--item-index: ${index};`}
          >
            <FeatureCard {...feature} />
          </div>
        ))}
      </div>
    </div>

    <div class="slider-nav flex items-center justify-center gap-4 sm:gap-6 mt-4 sm:mt-6">
      <button 
        class="nav-btn w-9 h-9 sm:w-12 sm:h-12 flex items-center justify-center text-white/60 hover:text-white transition-all"
        aria-label="Anterior"
      >
        <svg class="w-5 h-5 sm:w-8 sm:h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
        </svg>
      </button>
      <button 
        class="nav-btn w-9 h-9 sm:w-12 sm:h-12 flex items-center justify-center text-white/60 hover:text-white transition-all"
        aria-label="Siguiente"
      >
        <svg class="w-5 h-5 sm:w-8 sm:h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
        </svg>
      </button>
    </div>
  </div>
</section>

<style>
  .feature-slider {
    height: 100%;
    min-height: 200px;
  }

  .slider-wrapper {
    padding: 0.5rem 0;
    height: 100%;
    width: 100%;
  }

  .slider-container {
    height: 220px;
    position: relative;
    width: 100%;
  }

  .slider-track {
    position: relative;
    width: 100%;
    height: 100%;
  }

  .nav-btn:disabled {
    opacity: 0.2;
    cursor: not-allowed;
  }

  /* Tarjetas posicionadas absolutamente */
  .slider-item {
    transition: all 0.5s cubic-bezier(0.25, 0.1, 0.25, 1);
    transform-origin: center center;
    left: 50%;
    top: 50%;
    will-change: transform, filter, opacity;
  }

  /* Z-index según distancia */
  .slider-item.active {
    z-index: 10;
  }

  .slider-item.distance-1 {
    z-index: 8;
  }

  .slider-item.distance-2 {
    z-index: 6;
  }

  .slider-item.distance-3 {
    z-index: 4;
  }

  .slider-item.distance-4 {
    z-index: 2;
  }

  @media (min-width: 480px) {
    .slider-container {
      height: 240px;
    }

    .feature-slider {
      min-height: 220px;
    }
  }

  @media (min-width: 640px) {
    .slider-container {
      height: 280px;
    }
  }

  @media (min-width: 768px) {
    .slider-container {
      height: 300px;
    }

    .feature-slider {
      min-height: 260px;
    }
  }

  @media (max-width: 380px) {
    .slider-container {
      height: 200px;
    }

    .nav-btn {
      min-width: 40px;
      min-height: 40px;
    }
  }

  /* Móvil / táctil: ocultar flechas (no deben ocupar espacio) */
  @media (hover: none) and (pointer: coarse) {
    .slider-nav {
      display: none !important;
    }

    .slider-wrapper {
      padding-bottom: 0;
    }
  }
</style>

<script>

  // Escalas según distancia desde la tarjeta activa (más pronunciadas como en Figma)
  const SCALES = {
    0: 1.0,    // activa - tamaño completo
    1: 0.75,   // adyacente - notablemente más pequeña
    2: 0.58,   // distancia 2 - mucho más pequeña
    3: 0.45,   // distancia 3 - muy pequeña
    4: 0.35    // distancia 4+ - mínima
  };

  // Blur según distancia (en píxeles)
  const BLUR = {
    0: 0,      // activa - sin blur
    1: 2,      // adyacente - blur leve
    2: 4,      // distancia 2 - blur medio
    3: 6,      // distancia 3 - blur fuerte
    4: 8       // distancia 4+ - blur máximo
  };

  // Opacidad según distancia
  const OPACITY = {
    0: 1.0,    // activa
    1: 0.85,   // adyacente
    2: 0.6,    // distancia 2
    3: 0.4,    // distancia 3
    4: 0.25    // distancia 4+
  };

  function initSliderInstance(root: HTMLElement): void {
    const track = root.querySelector<HTMLElement>('.slider-track');
    const prevBtn = root.querySelector<HTMLButtonElement>('.nav-btn[aria-label="Anterior"]');
    const nextBtn = root.querySelector<HTMLButtonElement>('.nav-btn[aria-label="Siguiente"]');
    const items = root.querySelectorAll<HTMLElement>('.slider-item');

    if (!track || !prevBtn || !nextBtn || items.length === 0) return;

    if (track.hasAttribute('data-initialized')) return;
    track.setAttribute('data-initialized', 'true');

    const rawInitial = track.getAttribute('data-initial-index');
    const initialIndex = rawInitial !== null ? Math.max(0, parseInt(rawInitial, 10) % items.length) : 0;
    let currentIndex = initialIndex;
    const totalItems = items.length;

    const getCardWidth = (): number => {
      const w = window.innerWidth;
      if (w < 380) return 130;
      if (w < 480) return 140;
      if (w < 640) return 160;
      return 240;
    };

    const getGap = (): number => {
      const w = window.innerWidth;
      if (w < 380) return 8;
      if (w < 640) return 12;
      return 24;
    };

    // Calcular distancia circular (para loop infinito)
    const getCircularDistance = (index: number, current: number, total: number): number => {
      const directDistance = index - current;
      const wrapDistance = directDistance > 0 
        ? directDistance - total 
        : directDistance + total;
      
      // Retornar la distancia más corta
      return Math.abs(directDistance) <= Math.abs(wrapDistance) ? directDistance : wrapDistance;
    };

    const updateSlider = (): void => {
      const cardWidth = getCardWidth();
      const gap = getGap();

      // Posicionar cada tarjeta con distancia circular
      items.forEach((item, index) => {
        const distance = getCircularDistance(index, currentIndex, totalItems);
        const absDistance = Math.abs(distance);
        
        // Limpiar clases anteriores
        item.classList.remove('active', 'distance-1', 'distance-2', 'distance-3', 'distance-4');
        
        // Agregar clase según distancia
        if (absDistance === 0) {
          item.classList.add('active');
        } else if (absDistance === 1) {
          item.classList.add('distance-1');
        } else if (absDistance === 2) {
          item.classList.add('distance-2');
        } else if (absDistance === 3) {
          item.classList.add('distance-3');
        } else {
          item.classList.add('distance-4');
        }

        // Obtener valores según distancia
        const distKey = Math.min(absDistance, 4) as keyof typeof SCALES;
        const scale = SCALES[distKey];
        const blur = BLUR[distKey];
        const opacity = OPACITY[distKey];

        // Calcular posición X
        let xOffset = 0;
        
        for (let i = 0; i < absDistance; i++) {
          const prevScaleKey = Math.min(i, 4) as keyof typeof SCALES;
          const nextScaleKey = Math.min(i + 1, 4) as keyof typeof SCALES;
          const prevScale = SCALES[prevScaleKey];
          const nextScale = SCALES[nextScaleKey];
          xOffset += (cardWidth * prevScale / 2) + gap + (cardWidth * nextScale / 2);
        }

        if (distance < 0) xOffset = -xOffset;

        // Aplicar transformación, blur y opacidad
        item.style.transform = `translate(-50%, -50%) translateX(${xOffset}px) scale(${scale})`;
        item.style.filter = blur > 0 ? `blur(${blur}px)` : 'none';
        item.style.opacity = String(opacity);
      });

      // En loop infinito, los botones siempre están activos
      prevBtn.disabled = false;
      nextBtn.disabled = false;
    };

    // Navegación circular (loop infinito)
    const nextSlide = (): void => {
      currentIndex = (currentIndex + 1) % totalItems;
      updateSlider();
    };

    const prevSlide = (): void => {
      currentIndex = (currentIndex - 1 + totalItems) % totalItems;
      updateSlider();
    };

    // Auto-slide cada 5 segundos (loop infinito)
    let autoSlideInterval: ReturnType<typeof setInterval> | null = null;

    const startAutoSlide = (): void => {
      stopAutoSlide();
      autoSlideInterval = setInterval(() => {
        nextSlide();
      }, 5000);
    };

    const stopAutoSlide = (): void => {
      if (autoSlideInterval) {
        clearInterval(autoSlideInterval);
        autoSlideInterval = null;
      }
    };

    const resetAutoSlide = (): void => {
      startAutoSlide();
    };

    // Event listeners
    prevBtn.addEventListener('click', () => {
      prevSlide();
      resetAutoSlide();
    });

    nextBtn.addEventListener('click', () => {
      nextSlide();
      resetAutoSlide();
    });

    // Soporte para gestos táctiles
    let touchStartX = 0;

    track.parentElement?.addEventListener('touchstart', (e: TouchEvent) => {
      touchStartX = e.changedTouches[0].screenX;
      stopAutoSlide();
    }, { passive: true });

    track.parentElement?.addEventListener('touchend', (e: TouchEvent) => {
      const touchEndX = e.changedTouches[0].screenX;
      const diff = touchStartX - touchEndX;
      
      if (Math.abs(diff) > 50) {
        if (diff > 0) {
          nextSlide();
        } else {
          prevSlide();
        }
      }
      resetAutoSlide();
    }, { passive: true });

    // Soporte para teclado
    document.addEventListener('keydown', (e: KeyboardEvent) => {
      if (e.key === 'ArrowLeft') {
        prevSlide();
        resetAutoSlide();
      }
      if (e.key === 'ArrowRight') {
        nextSlide();
        resetAutoSlide();
      }
    });

    // Pausar auto-slide cuando el usuario hace hover
    track.parentElement?.addEventListener('mouseenter', stopAutoSlide);
    track.parentElement?.addEventListener('mouseleave', startAutoSlide);

    // Inicializar
    updateSlider();
    startAutoSlide();

    // Re-calcular en resize
    window.addEventListener('resize', updateSlider);

    // Limpiar interval cuando se desmonta
    window.addEventListener('beforeunload', stopAutoSlide);
  }

  function initAllSliders(): void {
    // Inicializar todos los sliders visibles en la página
    const sliders = document.querySelectorAll<HTMLElement>('[data-feature-slider]');
    sliders.forEach((slider) => {
      // Solo inicializar si el slider es visible
      const style = window.getComputedStyle(slider);
      const parentStyle = slider.parentElement ? window.getComputedStyle(slider.parentElement) : null;
      const isVisible = style.display !== 'none' && 
                       style.visibility !== 'hidden' && 
                       (!parentStyle || parentStyle.display !== 'none');
      
      if (isVisible) {
        initSliderInstance(slider);
      }
    });
  }

  function runInit(): void {
    requestAnimationFrame(() => {
      requestAnimationFrame(() => {
        initAllSliders();
      });
    });
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', runInit);
  } else {
    runInit();
  }

  document.addEventListener('astro:page-load', () => {
    document.querySelectorAll('[data-feature-slider] .slider-track').forEach((el) => {
      el.removeAttribute('data-initialized');
    });
    runInit();
  });

  // Re-inicializar cuando cambia el tamaño de pantalla (por si cambia de desktop a mobile)
  let resizeTimeout: ReturnType<typeof setTimeout>;
  window.addEventListener('resize', () => {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(() => {
      initAllSliders();
    }, 250);
  });
</script>
