---
import FeatureCard from './FeatureCard.astro';

interface Props {
  /** Tarjeta activa al cargar: 0=Chat, 1=Wallet, 2=Marketplace… Default 2 */
  initialIndex?: number;
}

const { initialIndex = 2 } = Astro.props;

// Slider: 9 tarjetas (Chat, Wallet, Marketplace, Apps, Nutrition, Comunidades, Música, Salud Mental, AI Finanzas)
const features = [
  {
    // Chat (0, activo por defecto)
    image: '/images/Chat.svg',
    logo: '/images/logohorizontal.svg',
    title: 'Chat',
    description: 'Comunicación segura, instantánea e inteligente.',
    titleKey: 'features.chat.title',
    descriptionKey: 'features.chat.description',
    link: '/chat'
  },
  {
    image: '/images/wallet.svg',
    logo: '/images/logohorizontal.svg',
    title: 'Wallet',
    description: 'Tu billetera digital segura y conectada.',
    titleKey: 'features.wallet.title',
    descriptionKey: 'features.wallet.description',
    link: '/wallet'
  },
  {
    image: '/images/marketplace.svg',
    logo: '/images/logohorizontal.svg',
    title: 'Marketplace',
    description: 'Compra y vende de forma segura.',
    titleKey: 'features.marketplace.title',
    descriptionKey: 'features.marketplace.description',
    link: '/marketplace'
  },
  {
    image: '/images/apps.svg',
    logo: '/images/logohorizontal.svg',
    title: 'Apps',
    description: 'Una sola puerta a cientos de soluciones.',
    titleKey: 'features.apps.title',
    descriptionKey: 'features.apps.description',
    link: '/apps'
  },
  {
    image: '/images/nutrition.svg',
    logo: '/images/logohorizontal.svg',
    title: 'Nutrition',
    description: 'Alimentación inteligente para tu bienestar.',
    titleKey: 'features.nutrition.title',
    descriptionKey: 'features.nutrition.description',
    link: '/nutrition'
  },
  {
    image: '/images/Community.svg',
    logo: '/images/logohorizontal.svg',
    title: 'Comunidades',
    description: 'Conecta con personas afines a ti.',
    titleKey: 'features.communities.title',
    descriptionKey: 'features.communities.description'
  },
  {
    image: '/images/musica.svg',
    logo: '/images/logohorizontal.svg',
    title: 'Música',
    description: 'Tu soundtrack personalizado.',
    titleKey: 'features.music.title',
    descriptionKey: 'features.music.description'
  },
  {
    image: '/images/mental.svg',
    logo: '/images/logohorizontal.svg',
    title: 'Salud Mental',
    description: 'Bienestar emocional con apoyo inteligente.',
    titleKey: 'features.mentalHealth.title',
    descriptionKey: 'features.mentalHealth.description'
  },
  {
    image: '/images/AiFinanzas.svg',
    logo: '/images/logohorizontal.svg',
    title: 'A.I. Finanzas',
    description: 'Gestión financiera inteligente y personalizada.',
    titleKey: 'features.finance.title',
    descriptionKey: 'features.finance.description'
  }
];

---

<section class="feature-slider relative w-full flex flex-col items-center justify-center overflow-visible" data-feature-slider>
  <div class="slider-wrapper relative w-full flex flex-col items-center justify-center flex-1 min-h-0">
    <div class="slider-container relative w-full flex-1 overflow-visible min-h-[320px]">
      <div 
        class="slider-track flex items-center justify-center"
        data-initial-index={initialIndex}
      >
        {features.map((feature, index) => (
          <div 
            class="slider-item absolute" 
            data-index={index}
            style={`--item-index: ${index};`}
          >
            <FeatureCard {...feature} />
          </div>
        ))}
      </div>
    </div>

    <div class="slider-nav flex items-center justify-center gap-4 sm:gap-6 mt-4 sm:mt-6">
      <button 
        class="nav-btn w-9 h-9 sm:w-12 sm:h-12 flex items-center justify-center text-white/60 hover:text-white transition-all"
        aria-label="Anterior"
      >
        <svg class="w-5 h-5 sm:w-8 sm:h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
        </svg>
      </button>
      <button 
        class="nav-btn w-9 h-9 sm:w-12 sm:h-12 flex items-center justify-center text-white/60 hover:text-white transition-all"
        aria-label="Siguiente"
      >
        <svg class="w-5 h-5 sm:w-8 sm:h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
        </svg>
      </button>
    </div>
  </div>
</section>

<style>
  .feature-slider {
    height: 100%;
    min-height: 200px;
  }

  .slider-wrapper {
    padding: 0.5rem 0;
    height: 100%;
    width: 100%;
  }

  .slider-container {
    height: 220px;
    position: relative;
    width: 100%;
  }

  .slider-track {
    position: relative;
    width: 100%;
    height: 100%;
  }

  .nav-btn:disabled {
    opacity: 0.2;
    cursor: not-allowed;
  }

  /* Tarjetas posicionadas absolutamente */
  .slider-item {
    transition: all 0.5s cubic-bezier(0.25, 0.1, 0.25, 1);
    transform-origin: center center;
    left: 50%;
    top: 50%;
    will-change: transform, filter, opacity;
  }

  /* Z-index según distancia */
  .slider-item.active {
    z-index: 10;
  }

  .slider-item.distance-1 {
    z-index: 8;
  }

  .slider-item.distance-2 {
    z-index: 6;
  }

  .slider-item.distance-3 {
    z-index: 4;
  }

  .slider-item.distance-4 {
    z-index: 2;
  }

  @media (min-width: 480px) {
    .slider-container {
      height: 240px;
    }

    .feature-slider {
      min-height: 220px;
    }
  }

  @media (min-width: 640px) {
    .slider-container {
      height: 280px;
    }
  }

  @media (min-width: 768px) {
    .slider-container {
      height: 300px;
    }

    .feature-slider {
      min-height: 260px;
    }
  }

  @media (max-width: 380px) {
    .slider-container {
      height: 200px;
    }

    .nav-btn {
      min-width: 40px;
      min-height: 40px;
    }
  }

  /* Móvil / táctil: ocultar flechas (no deben ocupar espacio) */
  @media (hover: none) and (pointer: coarse) {
    .slider-nav {
      display: none !important;
    }

    .slider-wrapper {
      padding-bottom: 0;
    }
  }
</style>

<script>

  // Escalas según distancia desde la tarjeta activa (más pronunciadas como en Figma)
  const SCALES = {
    0: 1.0,    // activa - tamaño completo
    1: 0.75,   // adyacente - notablemente más pequeña
    2: 0.58,   // distancia 2 - mucho más pequeña
    3: 0.45,   // distancia 3 - muy pequeña
    4: 0.35    // distancia 4+ - mínima
  };

  // Blur según distancia (en píxeles)
  const BLUR = {
    0: 0,      // activa - sin blur
    1: 2,      // adyacente - blur leve
    2: 4,      // distancia 2 - blur medio
    3: 6,      // distancia 3 - blur fuerte
    4: 8       // distancia 4+ - blur máximo
  };

  // Opacidad según distancia
  const OPACITY = {
    0: 1.0,    // activa
    1: 0.85,   // adyacente
    2: 0.6,    // distancia 2
    3: 0.4,    // distancia 3
    4: 0.25    // distancia 4+
  };

  // Asset mapping (Index -> { video, phone })
  // 0: Chat -> an1.mp4, s1.png
  // 1: Wallet -> an2.mp4, s2.png
  // ...
  const ASSETS = [
    { video: '/asad/an1.mp4', phone: '/asad/s1.png' }, // 0: Chat
    { video: '/asad/an2.mp4', phone: '/asad/s2.png' }, // 1: Wallet
    { video: '/asad/an3.mp4', phone: '/asad/s3.png' }, // 2: Marketplace
    { video: '/asad/an4.mp4', phone: '/asad/s4.png' }, // 3: Apps
    { video: '/asad/an5.mp4', phone: '/asad/s5.png' }, // 4: Nutrition
    { video: '/asad/an6.mp4', phone: '/asad/s6.png' }, // 5: Communities
    { video: '/asad/an7.mp4', phone: '/asad/s7.png' }, // 6: Music
    { video: '/asad/an8.mp4', phone: '/asad/s8.png' }, // 7: Mental Health
    { video: '/asad/an9.mp4', phone: '/asad/s9.png' }  // 8: Finance
  ];

  // Content mapping (Index -> { titleLine1, titleLine2, subtitle })
  const CONTENT = [
    { // 0: Chat
      titleLine1: 'Todo empieza',
      titleLine2: 'con una conversación',
      subtitle: 'Y desde ahí: paga, vende, sana o escucha música. Sin salir del chat.'
    },
    { // 1: Wallet
      titleLine1: 'Maneja tus finanzas',
      titleLine2: 'sin salir del chat',
      subtitle: 'Desde productos locales hasta servicios digitales: todo en una sola comunidad.'
    },
    { // 2: Marketplace
      titleLine1: 'Compra y vende',
      titleLine2: 'sin salir del chat',
      subtitle: 'Desde productos locales hasta servicios digitales: todo en una sola comunidad.'
    },
    { // 3: Apps
      titleLine1: 'Una sola app',
      titleLine2: 'Cientos de soluciones.',
      subtitle: 'Todo lo que necesitas, en un solo lugar. Como si fuera magia.'
    },
    { // 4: Nutrition
      titleLine1: 'Vive saludable',
      titleLine2: 'Con los tuyos.',
      subtitle: 'Comparte recetas, retos saludables y planes de alimentación en tu red.'
    },
    { // 5: Communities
      titleLine1: 'Destácate',
      titleLine2: 'Crea tu comunidad',
      subtitle: 'Crea, únete y colabora con personas que comparten tus intereses y valores.'
    },
    { // 6: Music
      titleLine1: 'La música vive',
      titleLine2: 'Escúchala y comparte.',
      subtitle: 'Tus canciones, tus playlists y nuevos descubrimientos. Todo en un solo lugar.'
    },
    { // 7: Mental Health
      titleLine1: 'Apoyo real',
      titleLine2: 'Que inspira confianza.',
      subtitle: 'Herramientas de bienestar emocional para ti y tu comunidad de apoyo.'
    },
    { // 8: Finance
      titleLine1: 'A.I. Finanzas',
      titleLine2: 'Tu asesor personal',
      subtitle: 'Gestión financiera inteligente y personalizada.'
    }
  ];

  // Links mapping (Index -> link)
  const LINKS = [
    '/chat/details',       // 0: Chat
    '/chat/wallet',     // 1: Wallet
    '/chat/marketplace',// 2: Marketplace
    '/chat/apps',       // 3: Apps
    '/chat/nutrition', // 4: Nutrition
    '/chat/communities', // 5: Communities
    '/chat/music', // 6: Music
    '/chat/health', // 7: Mental Health
    '/chat/finance'  // 8: Finance
  ];

  // Video preloading cache
  const videoPreloadCache = new Map<string, boolean>();
  
  function preloadVideo(videoSrc: string): void {
    if (videoPreloadCache.has(videoSrc)) return;
    
    const video = document.createElement('video');
    video.preload = 'auto';
    video.src = videoSrc;
    video.load();
    videoPreloadCache.set(videoSrc, true);
  }

  // Image preloading cache
  const imagePreloadCache = new Map<string, boolean>();

  function preloadImage(src: string): void {
    if (imagePreloadCache.has(src)) return;
    const img = new Image();
    img.src = src;
    imagePreloadCache.set(src, true);
  }

  function preloadAllImages(): void {
    ASSETS.forEach(asset => {
        if (asset.phone) preloadImage(asset.phone);
    });
  }

  function preloadNextAssets(currentIndex: number, totalItems: number): void {
    // Preload next 3 videos for smoother experience (Images are already preloaded)
    for (let i = 1; i <= 3; i++) {
        const nextIndex = (currentIndex + i) % totalItems;
        const asset = ASSETS[nextIndex];
        if (asset && asset.video) {
            preloadVideo(asset.video);
        }
    }
  }

  function initSliderInstance(root: HTMLElement): void {
    const track = root.querySelector<HTMLElement>('.slider-track');
    const prevBtn = root.querySelector<HTMLButtonElement>('.nav-btn[aria-label="Anterior"]');
    const nextBtn = root.querySelector<HTMLButtonElement>('.nav-btn[aria-label="Siguiente"]');
    const items = root.querySelectorAll<HTMLElement>('.slider-item');
    
    // Find the layout scope for this slider (mobile vs desktop)
    const layoutScope = root.closest('.chat-mobile-layout') || 
                         root.closest('.chat-desktop-layout') || 
                         root.closest('.home-hero') || 
                         document;
    
    // External elements to update (scoped to the correct layout)
    const heroVideo = layoutScope.querySelector('#home-hero-video') as HTMLVideoElement ||
                      document.getElementById('home-hero-video') as HTMLVideoElement;
    const heroPhoneCurrent = layoutScope.querySelector('#hero-phone-image') as HTMLImageElement ||
                      document.getElementById('hero-phone-image') as HTMLImageElement;
    const heroPhoneNext = layoutScope.querySelector('#hero-phone-next') as HTMLImageElement ||
                      document.getElementById('hero-phone-next') as HTMLImageElement;
    
    // Text elements to update (scoped)
    const heroTitle1 = layoutScope.querySelector('#hero-title-line1') as HTMLElement ||
                       document.getElementById('hero-title-line1');
    const heroTitle2 = layoutScope.querySelector('#hero-title-line2') as HTMLElement ||
                       document.getElementById('hero-title-line2');
    const heroSubtitle = layoutScope.querySelector('#hero-subtitle') as HTMLElement ||
                         document.getElementById('hero-subtitle');
    const heroCta = layoutScope.querySelector('#hero-cta-button') as HTMLElement ||
                    document.getElementById('hero-cta-button');

    // Optimize phone animation
    if (heroPhoneCurrent) heroPhoneCurrent.style.willChange = 'opacity, transform';
    if (heroPhoneNext) heroPhoneNext.style.willChange = 'opacity, transform';

    if (!track || !prevBtn || !nextBtn || items.length === 0) return;

    if (track.hasAttribute('data-initialized')) return;
    track.setAttribute('data-initialized', 'true');

    const rawInitial = track.getAttribute('data-initial-index');
    const initialIndex = rawInitial !== null ? Math.max(0, parseInt(rawInitial, 10) % items.length) : 0;
    let currentIndex = initialIndex;
    const totalItems = items.length;
    let isFirstUpdate = true;

    const getCardWidth = (): number => {
      const w = window.innerWidth;
      if (w < 380) return 130;
      if (w < 480) return 140;
      if (w < 640) return 160;
      return 240;
    };

    const getGap = (): number => {
      const w = window.innerWidth;
      if (w < 380) return -10;
      if (w < 640) return -15;
      return -20;
    };

    // Calcular distancia circular (para loop infinito)
    const getCircularDistance = (index: number, current: number, total: number): number => {
      const directDistance = index - current;
      const wrapDistance = directDistance > 0 
        ? directDistance - total 
        : directDistance + total;
      
      // Retornar la distancia más corta
      return Math.abs(directDistance) <= Math.abs(wrapDistance) ? directDistance : wrapDistance;
    };

    const updateSlider = (): void => {
      const cardWidth = getCardWidth();
      const gap = getGap();

      // Posicionar cada tarjeta con distancia circular
      items.forEach((item, index) => {
        const distance = getCircularDistance(index, currentIndex, totalItems);
        const absDistance = Math.abs(distance);
        
        // Limpiar clases anteriores
        item.classList.remove('active', 'distance-1', 'distance-2', 'distance-3', 'distance-4');
        
        // Agregar clase según distancia
        if (absDistance === 0) {
          item.classList.add('active');
        } else if (absDistance === 1) {
          item.classList.add('distance-1');
        } else if (absDistance === 2) {
          item.classList.add('distance-2');
        } else if (absDistance === 3) {
          item.classList.add('distance-3');
        } else {
          item.classList.add('distance-4');
        }

        // Obtener valores según distancia
        const distKey = Math.min(absDistance, 4) as keyof typeof SCALES;
        const scale = SCALES[distKey];
        const blur = BLUR[distKey];
        const opacity = OPACITY[distKey];

        // Calcular posición X
        let xOffset = 0;
        
        for (let i = 0; i < absDistance; i++) {
          const prevScaleKey = Math.min(i, 4) as keyof typeof SCALES;
          const nextScaleKey = Math.min(i + 1, 4) as keyof typeof SCALES;
          const prevScale = SCALES[prevScaleKey];
          const nextScale = SCALES[nextScaleKey];
          xOffset += (cardWidth * prevScale / 2) + gap + (cardWidth * nextScale / 2);
        }

        if (distance < 0) xOffset = -xOffset;

        // Aplicar transformación, blur y opacidad
        item.style.transform = `translate(-50%, -50%) translateX(${xOffset}px) scale(${scale})`;
        item.style.filter = blur > 0 ? `blur(${blur}px)` : 'none';
        item.style.opacity = String(opacity);
      });

      // En loop infinito, los botones siempre están activos
      prevBtn.disabled = false;
      nextBtn.disabled = false;

      // Update external assets based on currentIndex
      if (ASSETS[currentIndex]) {
        const { video, phone } = ASSETS[currentIndex];
        
        // Update Video if changed - INSTANT sync with slider
        if (heroVideo) {
          // Extract filename from current video src for comparison
          const currentVideoSrc = heroVideo.src || '';
          const currentFileName = currentVideoSrc.split('/').pop()?.split('?')[0] || '';
          const newFileName = video.split('/').pop()?.split('?')[0] || '';
          
          // Only update if the video file is actually different
          if (currentFileName !== newFileName) {
            const wasPlaying = !heroVideo.paused;
            
            // Instantly update video source - no delay to match slider timing
            heroVideo.style.transition = 'opacity 0.5s cubic-bezier(0.25, 0.1, 0.25, 1)';
            heroVideo.style.opacity = '0.4';
            
            // Change source immediately
            heroVideo.src = video;
            heroVideo.load();
            
            // Fade in as soon as ready
            const onCanPlay = () => {
              heroVideo.removeEventListener('canplay', onCanPlay);
              heroVideo.style.opacity = '0.85';
              
              // Auto-play new video (will fallback to muted if blocked)
              if (wasPlaying) {
                heroVideo.play().catch(err => {
                  // If blocked, try muted
                  heroVideo.muted = true;
                  heroVideo.play().catch(() => {});
                });
              }
            };
            
            heroVideo.addEventListener('canplay', onCanPlay, { once: true });
            
            // Fallback: restore opacity even if video doesn't load quickly
            setTimeout(() => {
              if (heroVideo.style.opacity !== '0.85') {
                heroVideo.style.opacity = '0.85';
                heroVideo.removeEventListener('canplay', onCanPlay);
              }
            }, 800);
          }
        }

        // Update Phone Image if changed - sync with slider timing
        // Double buffering logic for smooth transition
        const heroPhoneCurrent = (layoutScope.querySelector('#hero-phone-image') || document.getElementById('hero-phone-image')) as HTMLImageElement;
        const heroPhoneNext = (layoutScope.querySelector('#hero-phone-next') || document.getElementById('hero-phone-next')) as HTMLImageElement;

        if (heroPhoneCurrent && heroPhoneNext) {
            // Check if we need to update
            // We look at the "active" one's src to see if it matches current phone
            // Actually, we should track which one is currently "active" via class
            
            let activeImg = heroPhoneCurrent.classList.contains('active') ? heroPhoneCurrent : heroPhoneNext;
            let nextImg = activeImg === heroPhoneCurrent ? heroPhoneNext : heroPhoneCurrent;
            
            // If active image already has the correct src, do nothing
             if (!activeImg.src.includes(phone)) {
                if (isFirstUpdate) {
                    // Initial load
                    activeImg.src = phone;
                    activeImg.style.opacity = '1';
                    activeImg.style.transform = 'translateY(0)';
                    
                    nextImg.style.opacity = '0';
                    nextImg.style.transform = 'translateY(0)';
                } else {
                    // Prepare Next Image (It's already "there" behind, just needs src update)
                    nextImg.src = phone;
                    nextImg.style.transition = 'none'; // Instant reset
                    nextImg.style.opacity = '0'; // Start hidden
                    nextImg.style.transform = 'translateY(0) scale(0.95)'; // Slightly smaller for depth effect? Or just 0
                    // User said "next image should look like already present", so scale(1) translateY(0) behind is best.
                     nextImg.style.transform = 'translateY(0) scale(1)';
                    
                    // Force reflow
                    void nextImg.offsetWidth;
                    
                    // Animate!
                    // 1. Current Image: Exits UP and OUT (Slower)
                    activeImg.style.transition = 'transform 1.5s cubic-bezier(0.16, 1, 0.3, 1), opacity 0.5s ease-in 0.3s';
                    activeImg.style.transform = 'translateY(-150vh)';
                    activeImg.style.opacity = '0';
                    activeImg.style.zIndex = '10'; // On top while exiting
                    activeImg.classList.remove('active');
                    
                    // 2. Next Image: Immediate Appear (behind)
                    // The user wants it to look "already present", so we show it immediately behind the exiting one.
                    nextImg.style.transition = 'none';
                    nextImg.style.opacity = '1';
                    nextImg.style.transform = 'translateY(0)';
                    nextImg.style.zIndex = '9'; // Behind
                    nextImg.classList.add('active');
                    
                    // Cleanup old image after animation
                     setTimeout(() => {
                        activeImg.style.transition = 'none';
                        activeImg.style.transform = 'translateY(0)';
                        activeImg.style.zIndex = '0';
                    }, 1500);
                }
             }
        } else if (heroPhoneCurrent) {
           // Fallback for single image (if overlay update failed)
           if (!heroPhoneCurrent.src.includes(phone)) {
             heroPhoneCurrent.src = phone;
           }
        }
      }

      // Update Text Content if changed - sync with slider timing
      if (CONTENT[currentIndex]) {
        const { titleLine1, titleLine2, subtitle } = CONTENT[currentIndex];
        const textChanged = (heroTitle1 && heroTitle1.textContent !== titleLine1) ||
                           (heroTitle2 && heroTitle2.textContent !== titleLine2) ||
                           (heroSubtitle && heroSubtitle.textContent !== subtitle);

        if (textChanged && !isFirstUpdate) {
          // Quick fade out - match slider timing
          const titleEls = [heroTitle1, heroTitle2].filter(Boolean) as HTMLElement[];
          const subtitleEl = heroSubtitle;

          titleEls.forEach(el => {
            el.style.transition = 'opacity 0.25s cubic-bezier(0.25, 0.1, 0.25, 1)';
            el.style.opacity = '0';
          });
          if (subtitleEl) {
            subtitleEl.style.transition = 'opacity 0.25s cubic-bezier(0.25, 0.1, 0.25, 1)';
            subtitleEl.style.opacity = '0';
          }

          setTimeout(() => {
            // Set new text
            if (heroTitle1) heroTitle1.textContent = titleLine1;
            if (heroTitle2) heroTitle2.textContent = titleLine2;
            if (heroSubtitle) heroSubtitle.textContent = subtitle;

            // Fade in quickly
            requestAnimationFrame(() => {
              titleEls.forEach(el => {
                el.style.transition = 'opacity 0.3s cubic-bezier(0.25, 0.1, 0.25, 1)';
                el.style.opacity = '1';
              });
              if (subtitleEl) {
                subtitleEl.style.transition = 'opacity 0.3s cubic-bezier(0.25, 0.1, 0.25, 1)';
                subtitleEl.style.opacity = '1';
              }
            });
          }, 150);
        } else {
          // First update or no change — set directly
          if (heroTitle1 && heroTitle1.textContent !== titleLine1) heroTitle1.textContent = titleLine1;
          if (heroTitle2 && heroTitle2.textContent !== titleLine2) heroTitle2.textContent = titleLine2;
          if (heroSubtitle && heroSubtitle.textContent !== subtitle) heroSubtitle.textContent = subtitle;
        }
      }

      // Update CTA Link
      if (heroCta) {
        const link = LINKS[currentIndex];
        if (link) {
          heroCta.setAttribute('href', link);
        } else {
          // Fallback or keep current? Maybe fallback to '#' or root?
          // For now, let's just leave it or set to '#' to avoid broken links if user clicks
          // But 'ver más' implies there is something to see. 
          // If no link, maybe we should hide it? But design might require it.
          // Let's default to specific section or just '#'
          heroCta.setAttribute('href', '#');
        }
      }

      isFirstUpdate = false;
      
      // Preload next assets (videos and images) for smooth transitions
      preloadNextAssets(currentIndex, totalItems);
    };

    // Navegación circular (loop infinito)
    const nextSlide = (): void => {
      currentIndex = (currentIndex + 1) % totalItems;
      updateSlider();
    };

    const prevSlide = (): void => {
      currentIndex = (currentIndex - 1 + totalItems) % totalItems;
      updateSlider();
    };

    // Auto-slide cada 5 segundos (loop infinito)
    let autoSlideInterval: ReturnType<typeof setInterval> | null = null;

    const startAutoSlide = (): void => {
      stopAutoSlide();
      autoSlideInterval = setInterval(() => {
        nextSlide();
      }, 5000);
    };

    const stopAutoSlide = (): void => {
      if (autoSlideInterval) {
        clearInterval(autoSlideInterval);
        autoSlideInterval = null;
      }
    };

    const resetAutoSlide = (): void => {
      startAutoSlide();
    };

    // Event listeners
    prevBtn.addEventListener('click', () => {
      prevSlide();
      resetAutoSlide();
    });

    nextBtn.addEventListener('click', () => {
      nextSlide();
      resetAutoSlide();
    });

    // Soporte para gestos táctiles
    let touchStartX = 0;

    track.parentElement?.addEventListener('touchstart', (e: TouchEvent) => {
      touchStartX = e.changedTouches[0].screenX;
      stopAutoSlide();
    }, { passive: true });

    track.parentElement?.addEventListener('touchend', (e: TouchEvent) => {
      const touchEndX = e.changedTouches[0].screenX;
      const diff = touchStartX - touchEndX;
      
      if (Math.abs(diff) > 50) {
        if (diff > 0) {
          nextSlide();
        } else {
          prevSlide();
        }
      }
      resetAutoSlide();
    }, { passive: true });

    // Soporte para teclado
    document.addEventListener('keydown', (e: KeyboardEvent) => {
      if (e.key === 'ArrowLeft') {
        prevSlide();
        resetAutoSlide();
      }
      if (e.key === 'ArrowRight') {
        nextSlide();
        resetAutoSlide();
      }
    });

    // Click on slider to scroll (Right to Left / Next)
    // Avoid double triggering if button clicked (buttons are outside, but check anyway)
    // Check if dragging happened? Since touchStart/touchEnd are passive, click might fire.
    // If we want simple click behavior:
    track.parentElement?.addEventListener('click', (e) => {
      // Bounce animation: Move right first (wind up)
      track.style.transition = 'transform 0.15s ease-out';
      track.style.transform = 'translateX(20px)';

      setTimeout(() => {
        // Then trigger next slide (scroll left) and reset track
        nextSlide();
        resetAutoSlide();
        track.style.transform = 'translateX(0)';
      }, 150);
    });

    // Pausar auto-slide cuando el usuario hace hover
    track.parentElement?.addEventListener('mouseenter', stopAutoSlide);
    track.parentElement?.addEventListener('mouseleave', startAutoSlide);

    // Inicializar
    updateSlider();
    startAutoSlide();

    // Re-calcular en resize
    window.addEventListener('resize', updateSlider);

    // Limpiar interval cuando se desmonta
    window.addEventListener('beforeunload', stopAutoSlide);
  }

  function initAllSliders(): void {
    // Inicializar todos los sliders visibles en la página
    const sliders = document.querySelectorAll<HTMLElement>('[data-feature-slider]');
    sliders.forEach((slider) => {
      // Solo inicializar si el slider es visible
      const style = window.getComputedStyle(slider);
      const parentStyle = slider.parentElement ? window.getComputedStyle(slider.parentElement) : null;
      const isVisible = style.display !== 'none' && 
                       style.visibility !== 'hidden' && 
                       (!parentStyle || parentStyle.display !== 'none');
      
      if (isVisible) {
        initSliderInstance(slider);
      }
    });
  }

  function runInit(): void {
    preloadAllImages();
    initAllSliders();
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', runInit);
  } else {
    runInit();
  }

  document.addEventListener('astro:page-load', () => {
    document.querySelectorAll('[data-feature-slider] .slider-track').forEach((el) => {
      el.removeAttribute('data-initialized');
    });
    runInit();
  });

  // Re-inicializar cuando cambia el tamaño de pantalla (por si cambia de desktop a mobile)
  let resizeTimeout: ReturnType<typeof setTimeout>;
  window.addEventListener('resize', () => {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(() => {
      initAllSliders();
    }, 250);
  });
  
  // Ensure phone is ready for transitions
  document.addEventListener('astro:page-load', () => {
      const p = document.getElementById('hero-phone-image');
      if(p) {
        p.style.transition = 'transform 0.5s cubic-bezier(0, 0, 0.2, 1), opacity 0.5s ease';
      }
  });
</script>
